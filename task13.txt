Для удаления максимума и минимума за О(1) достаточно реализовать отсортированную структуру данных - показано на примере двусвязного списка.

Далее допустим, что, по условию задачи, требуются вставка и удаление произвольного элемента. Эти операции можно выполнять за амортизированное О(1), если использовать словарь.
Но при этом невозможно обеспечить выполнение всех четырёх операций за константное время, так как словарь - это неупорядоченная структура данных.
Использование дополнительной памяти также не поможет, так как мы имеем проблему определения "предыдущего" максимума/минимума.
Для её решения нам необходима упорядоченная структура, что делает невозможным удаление максимума/минимума за константное время.

Оптимизация будет зависеть от более конкретных условий - какая операция наименее приоритетна по производительности.
Пример - если достаточно вставки/удаления в конец, а не в середину, то можно реализовать структуру данных на нескольких стеках, в которой дополнительный стек будет использоваться для хранения информации о максимальном/минимальном элементе. Это даст нам константную производительность для всех четырех операций.
Другой пример - использование самобалансирующихся деревьев даст нам логарифмическую сложность выполнения операций. Если все 4 операции используются с примерно одинаковой частотой, то это может быть более подходящим решением, чем связный список с линейной сложностью вставки/удаления.
Ещё один пример - если задача не предполагает хранение дубликатов, то мы можем реализовать связный список на основе словаря с парами (значение : кортеж с ссылками). Это позволит нам удалять произвольный элемент за константное время, таким образом, только вставка будет иметь линейную сложность.
